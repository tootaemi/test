package test;

public class JavaSilverSE11_1 {
	public static void main(String[] args) {
//		System.out.println("Hello, world!");
		
//		第7章
//		クラスの継承、インターフェース、抽象クラス
//		・クラスの継承
//		・インターフェース
//		・抽象クラスと具象クラス
//		・抽象メソッドの実装
//		・メソッドのオーバーライド
//		・ポリモーフィズム
//		・型の互換性、アップキャスト、ダウンキャスト
//		・thisの使用
//		・superの使用
		
		
		//1.
//		public class Child extends Parent {
//			Child() {
//				name = "Java";
//			}
//			void hello() {
//				System.out.println("hello, " + name);
//			}
//		}
		
		//このクラスが継承しているParentクラスの説明として正しいもの
		//⇨
		//Parentクラスには、nameフィールドを定義しなければいけない。
//		
//		クラスの継承に関する問題。
//		継承は、あるクラスを機能拡張した新しいクラスを定義すること。
//		拡張元になるクラスのことを基底クラスやスーパークラス、
//		拡張したクラスのことを派生クラスやサブクラスと呼ぶ。
//		
//		継承は生産性を向上させる強力なプログラミング手法。
//		共通部分のプログラム⇨差分プログラミングと呼ぶ。
////		
//		！　継承をすることでサブクラスはスーパークラスの特徴を引き継ぎます。
//		サブクラスのインスタンスは、スーパークラスのインスタンスと
//		差分のインスタンスの両方で構成されていることを理解しよう。
		
//		2. 継承の説明として正しいもの
//		⇨　サブクラスであってもコンストラクタは引き継ぎができない
//		
//		継承では何を引き継ぐかについて問う問題。
//		下記の2つは継承していても引き継げない
////		・コンストラクタ
////		・privateなフィールドやメソッド
//		
//		privateなフィールドやメソッドは、アクセス修飾子privateで修飾され、
//		同じクラスのインスタンス同志でしか使えない。
//		
//		デフォルトは「パッケージアクセス」とも呼ばれ、
//		同じパッケージに属するクラスのインスタンスからのアクセスだけを許可するもの。
//		継承関係でもスーパークラスとサブクラスのそれぞれが属するパッケージが異なれば
//		アクセスできない。
//		
//		protectedは異なるパッケージであっても
//		継承関係にあればアクセスを許可する
//		というもの。
//		
//		！　継承関係にあってもスーパークラスのコンストラクタと
//		privateなフィールドやメソッドはサブクラスには引き継がれない。
		
//		3.インターフェースに関する説明として正しいもの。
//		⇨
//		・アクセス修飾子を省略してもpublicなメソッドとして扱われる
//		・抽象クラスは、インターフェースに定義されているメソッドを実現しなくてもよい
//		
//		解説；
////		インターフェースの基礎知識を問う問題。
//		インターフェースは、クラスから「型」だけを取り出したもの。
//		型とはそのものの「扱い方」を決めるための情報
//		変数を宣言する時に型を指定するのはその変数の扱い方を決めるため。
//		注意すべきなのは扱う対象そのものの種類と型で指定する
//		「扱う対象の種類」は異なる概念であること。
//		インスタンスの種類と変数の型を分けて考えられるためポリモーフィズムが成り立つ。
	
//		インターフェースは他のクラスからの「扱い方」を規定したもの。
//		他のクラスから扱えるようにするために規定する抽象メソッドは
//		すべてpublicであると解釈される。
//		アクセス修飾子を記述しなくてもインターフェースは
//		コンパイルエラーによって自動的にpublicで修飾される。
//		
//		！　インターフェースに宣言する抽象メソッドには、
//		処理内容をいっさい記述することはできない。
//		
//		継承に関するルール
//		⇨　・クラス同士は単一継承のみ可能
//		　　・インターフェース同士は多重継承が可能
		
		//4.
//		public interface A {
//			void sample() {
//				System.out.println("sample");
//			}
//		}
//		public class B implements A {
//		
//		}
//		
//		public class Main {
//			public static void main(String[] args) {
//				A a = new B();
//				a.sample();
//			}
//		}
//
//		⇨　インターフェースAのsampleメソッドをdefaultで修飾しなければいけない。
//		解説；デフォルトメソッドに関する問題。
//		インターフェースに定義されている抽象メソッドはそのインターフェースを
//		実現したクラスが必ず実装しなければいけない。
		
		//5.結果として正しいもの
//		public interface A {
//			@Override
//			default String toString() {
//				return "A";
//			}
//		}
//				
//		public class B implements A {
//			@Override
//			public String toString() {
//				return "B";
//			}
//		}
//		
//		public class Main {
//			public static void main(String[] args) {
//				A a = new B();
//				System.out.println(a);
//			}
//		}
//		⇨　Aインターフェースでコンパイルエラーとなる。
//		解説；　インターフェースに定義するデフォルトメソッドは、
//		実現クラスが持つべきデフォルトの実装を定義するもの。
//		Aインターフェースでjava.lang.Objectクラスに
//		定義されているtoStringメソッドをデフォルトメソッドとして
//		オーバーライドしているためコンパイルエラーが発生する。
		
		//6.省略
		
		//7.結果として正しいもの。
//		public interface A {
//			default void test() {
//				System.out.println("A");
//			}
//		}
//		public interface B {
//			default void test() {
//				System.out.println("B");
//			}
//		}
//		public class Main implements A, B {
//			public static void main(String[] args) {
//				new Main().test();
//			}
//		}
//		//→　コンパイルエラーが発生する。
//		このコード例では、MainクラスがAインターフェースとBインターフェースの両方を実装していますが、
//		両方のインターフェースにtestメソッドのデフォルト実装が存在します。
//		Javaでは、同一のシグネチャを持つメソッドの複数のデフォルト実装を持つインターフェースを
//		一つのクラスが実装しようとすると、どちらのデフォルトメソッドを使用すべきか
//		Javaコンパイラが決定できないため、コンパイルエラーが発生します。
//		
//このコードには、Main クラスが A と B 両方のインターフェースを実装しており、
//それぞれのインターフェースには同じシグネチャのデフォルトメソッド test() が定義されています。
//Javaでは、異なるインターフェースのデフォルトメソッド間で名前とシグネチャが衝突する場合、
//コンパイルエラーが発生します。これは、Javaコンパイラがどちらの test() メソッドを
//Main クラスで呼び出すべきかを自動的に判断できないためです。
//
//この問題を解決するには、Main クラス内で test() メソッドをオーバーライドして、
//どちらのインターフェースのメソッドを使用するか明示的に指定する必要
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}