package test;

public class Bronze {
	public static void main(String[] args) {
//		System.out.println("こんにちは。");
		

//		1日目
//		1、javaの概要
//		2、変数、データ型、演算子
		
//		
//		1-4 プログラミングを始める
//
//		字下げはTabキーを押す。スペースで字下げしない。
//		因みに、MacのタブキーはQの左隣
//		
//		1-5  javaのプログラムが動く仕組み
//		Point!
//		・コンパイルとはコンピュータがソースコードを理解できるように翻訳すること
//		・コンパイルするための翻訳プログラムのことを「コンパイラ」という
//		・コンパイラを2回行い2回目のコンパイルはプログラムの実行時にJVMを使ってマシン語に翻訳している。
//		
//		翻訳作業のことを「コンパイル」
//		翻訳前のコードを「ソースコード」
//		ソースコードをコンパイルするための翻訳プログラムのことを「コンパイラ」と呼ぶ。
//		
//		1-6 プログラムを構成するもの
//		point!
//		・1つのプログラム部品のことを「クラス」という。
//		・ブロックとはコードの塊を表す集合体のことで「{」から「}」で表す。
//		・コード中の命令のことを「ステートメント」
//		プログラムの実行中に扱うデータのことを「リテラル」　という。
//		
		//・数値　ダブルクォーテーション「”」なしで記述できる。
		//・文字列　　ダブルクォーテーション「”」で括らなければいけない
//		
//		「”」で括ることでデータ型であることを明確に示している。
//		
//		2,変数、データ型、演算子
//		point!
//		・変数名　人が理解しやすいようにメモリアドレスにつける別名のこと
//		・変数名を使って実際のメモリアドレスを参照し
//		そこにあるデータにアクセスできるようにする仕組みのことを「変数」という。
//		・8種類のプリミティブ型	（short型、byte型、long型、int型、double型、float型、char型、boolean型）
//		のデータ型が用意されている。
//		・変数は宣言したのちに初期化することによって使うことができるようになる。
//		
		
//		
//		データ型は、プリミティブ型、オブジェクト型、列挙型の３つに分類される。
//		最も基本となるプリミティブ型を学ぶ。
//		基本データ型　とも呼ばれる。
//		
//		プリミティブ型
//		省略
//		
//		文字列と文字の違い
//		・文字・・・1文字しか使えない。char型（データ型）
//		・文字列・・・何文字でも扱える。String型（データ型）
		
//		定数とは値を変更できない定数。
//		
//		2-2　算術演算子
		//point　　　省略
		
//		int a = 10;
//		System.out.println(a % 3);
//		
//		10を3で割ると、確かに商は約3.33333333...となりますが、
//		プログラミングにおける剰余演算子`%`は除算の結果の商ではなく、
//		余りを求めるものです。したがって、10を3で割った場合の余りは1となります。
//		この余りが`System.out.println(a % 3);`によって出力される値です。
		
		//インクリメント、デクリメント
//		int a = 10;
//		int b = a++;
//		int c = ++a;
//		System.out.println(b);
//		System.out.println(c);
//
//		このJavaのコードは、`a`の値をインクリメント（1増加）しながら、
//		変数`b`と`c`に代入する操作を行っています。
//
//		1. `int a = 10;` で、変数`a`に10が代入されます。
//		2. `int b = a++;` で、`a`の現在の値（10）が`b`に代入された後、
//		`a`の値が1増加して11になります。ポストインクリメント演算子`a++`は、
//		値を代入した後にインクリメント（1増加）を行います。
//		3. `int c = ++a;` では、`a`の値が先に1増加して12になり、
//		その後で`c`に代入されます。プレインクリメント演算子`++a`は、
//		インクリメントを先に行い、その後で値を代入します。
//		したがって、最終的な出力は以下の通りです。
//		bの出力: 10
//		cの出力: 12
//		`b`は`a`がインクリメントされる前の値を保持し、
//		`c`は`a`が2回インクリメントされた後の値を保持します。
//		
//		iong a = 1;
//		int b = (int) a;
////		
//		大きい型から小さい型への変換はキャストしないとコンパイルエラーになる。
//		キャストを「明示的な型変換」と呼ぶ。
//		
//		→
//		「キャスト」とは、プログラミングにおいて、あるデータ型の変数や値を
//		別のデータ型に明示的に変換する操作のことを指します。
//		特に、「大きい型から小さい型への変換」の場合、このキャスト操作は必須となります。
//		これは、変換を試みる値が新しい型で扱える範囲外の可能性があるため、
//		プログラマがその変換の意図を明示的に示す必要があるからです。
//
//		例えば、`long`型（64ビット整数）から`int`型（32ビット整数）への変換では、
//		`long`型の範囲は`int`型のそれより広いため、
//		変換過程で値が`int`型の範囲に収まらない可能性があります。
//		このような場合、キャスト（型変換）を明示的に行うことで、
//		プログラマは意図的に範囲を狭め、情報の損失を受け入れていることをコンパイラに伝えます。
//
//		キャストの基本的な文法は、変換先の型を括弧`()`で囲み、
//		その後に変換したい変数や値を記述します。
//		例えば、`long`型の変数`a`を`int`型に変換する場合、以下のように書きます。
//
//		long a = 10000000000L;
//		int b = (int) a; // aをint型にキャストする
//
//		この操作により、`a`の値が`int`型の変数`b`に代入されますが、
//		もし`a`の値が`int`型で表現できる範囲を超えている場合、
//		結果は予測不可能（通常は値のトランケートが行われますが、正確な結果は言語や実装に依存します）
//		になり得るため、キャストを行う際には注意が必要です。
		
		
//		このコードスニペットには、`long`型の変数`a`を宣言し、
//		その値を`int`型の変数`b`にキャスト（型変換）しています。
//		ただし、コードの最初の行に「`iong`」というタイプミスがあり、
//		正しくは「`long`」です。正しく修正すると以下のようになります。
//
//		long a = 1;
//		int b = (int) a;
//
//		ここで、`long a = 1;`は`a`という名前の`long`型変数を宣言し、
//		それに1を代入しています。`long`型は64ビットの整数値を保持でき、
//		`int`型よりも大きな値を扱うことができます。
//
//		次に、`int b = (int) a;`は`a`の値を`int`型にキャストしています。
//		このキャストは、`long`型から`int`型への明示的な型変換を示しています。
//		この場合、`a`の値は1であり、`int`型の範囲内に収まるため、
//		変換は問題なく行われ、`b`は1という値を保持します。
//		型変換（キャスト）を使うことで、異なる型の値間での代入が可能になりますが、
//		元の値が新しい型で扱える範囲を超える場合、情報の損失が発生する可能性があります。
//		この例では、`long`型の値が`int`型で扱える範囲内にあるため、情報の損失はありません。
//		
//		
//		・小さい型から大きい型へはコンパイラが自動的に変換する・・・暗黙の型変換
//		・大きい型から小さい型へはプログラマーがキャストする。・・・明示的な
//		
//		※　キャストとはデータ型を変換すること。
//		特に明示的に変換するときキャストと呼ぶことが多い
		
//		
//		1日目のおさらい
//		問題　1
//		⇨　C
//		
//		問題　2
//		int num = 10;
//		int resuit = num++ % 4;
//		System.out.println(resuit);
//		
//		⇨　10を4で割った余りを求める
//		10割る4は2.5ですよね。
//		なので余らないと思うのですが
//		どう考えたらいいのでしょうか
//		
//		整数の割り算の場合、結果は整数部分のみとなり、小数点以下は無視されます。
//		したがって、10を4で割ると、結果は2になります（商は2）。
//		小数点以下の部分（0.5）は割り算の結果には含まれず、
//		剰余演算子`%`を使用した場合には余りとして扱われます。
//		この場合、10を4で割った余りは2になります。
//		整数の割り算では、商と余りを別々に考える必要があります。
//		商は整数部分のみで、余りは割り算で割り切れなかった部分です。
//		
//		10を4で割った場合、商は2で余りは2です。
//		割り算を行う際、特にプログラミングにおいて整数同士の除算では、
//		結果は整数部分のみを返し、小数点以下は無視されます。
//		ですので、10を4で割ると、商は2になり、余りは2です。
//		剰余演算子`%`はこの余りを求めるものです。
//		コードの説明において、あなたが言及している「10割る4は2.5ですよね。
//		なので余らない」というのは、割り算の結果を小数で表した場合の理解です。
//		しかし、剰余演算では小数点以下は考慮されず、
//		整数の割り算での余り（この場合は2）が結果として返されます。
//		したがって、
//		
//		int num = 10;
//		int result = num++ % 4;
//		System.out.println(result);
//		
//		は以下のように動作します。
//
//		1. `num`に10が代入されます。
//		2. `num++ % 4`は、`num`の現在の値（10）を4で割った余りを計算し、
//		その後`num`の値を1増やします。10を4で割った余りは2なので、
//		`result`には2が代入されます。
//		3. `System.out.println(result);`により、
//		`result`の値である2が出力されます。
//
//		結果的に、このコードは`2`を出力します。
//		
//		
//		
//		`num++`という表現は、"ポストインクリメント"演算子を使用しています。
//		これは、変数`num`の現在の値を使用した後、
//		その値を1増加させるという操作を意味します。したがって、`num++`が式内で使われるとき、まず`num`の現在の値（この場合は10）が式に使用され、その後`num`の値が1増加して11になります。
//
//		このコンテキストでの`int result = num++ % 4;`という行は、
//		以下の手順で実行されます：
//
//		1. `num`の現在の値（10）を取得します。
//		2. 取得した値（10）を4で割った余りを計算します。この余りは2です。
//		3. `result`変数に余り（2）を代入します。
//		4. `num`の値を1増加させ、`num`は11になります。
//
//		したがって、`System.out.println(result);`の出力は`2`になりますが、
//		その直後で`num`の値を確認すると、`num`は11になっています。
//		
//		
//		
//		int num = 10;
//		int result = num++ % 4;　　num++ 　は11ではないのですか
//		
//		それなら11割る4ですよね？　11割る4は2.75なのであまりが分からないです
//
//
//		
//		`num++ % 4`の操作についての混乱を解消しましょう。
//		この式では、`num++`が使用されているため、`num`の値は式の評価後に1増加しますが、
//		式の評価に使われるのは増加前の値です。
//		つまり、`num`が10のとき、`num++ % 4`の計算では10が使われ、
//		その後`num`は11になりますが、この計算での除算は`10 % 4`が行われます。
//
//		`11 % 4`についてのご質問ですが、実際に式で使用されているのは`10 % 4`です。
//		しかし、`11 % 4`の計算についても説明しますね。
//		11を4で割った場合の商は2で、余りは3です。整数の割り算では、結果は整数で表され、
//		割り算の余りは`%`演算子で求められます。したがって、11を4で割った余りは3になります。
//
//		要点を整理すると、`num++ % 4`の計算では
//		`num`の増加前の値（10）が使われ、10を4で割った余り、つまり2が`result`に代入されます。
//		その後、`num`の値は11になりますが、
//		この時点での`num`の値は`result`の計算には影響しません。
		

//		
//		ポストインクリメント（`num++`）のような操作は特に、実際にいくつかの例を通して
//		学んでいくと理解が深まります。以下に、ポストインクリメントの概念を
//		もう少し簡単に説明します。
//
//		### ポストインクリメント (`num++`)
//		- **動作**: 変数の現在の値を使用してから、その値を1増加させます。
//		- **例**: `num`が10の場合、`num++`の操作を行うと、
//		まず`num`の現在の値（10）が使用され、その操作が完了した後に
//		`num`は11になります。
//
//		### 例による説明
//		1. **初期状態**: `int num = 10;`
//		2. **操作**: `int result = num++ % 4;`
//		   - `num`の値（10）を取り、4で割った余りを計算します。10 % 4 = 2。
//		   - `result`には2が代入されます。
//		   - この操作の後、`num`の値は1増加して11になります。
//		3. **結果**: `System.out.println(result);`を実行すると、
//		`2`が出力されます。この時点で`num`の値は11です。
//
//		ポストインクリメントは、その行での値の使用後に増加が行われるため
//		、増加が行われる前の値がその行の操作に使用されます。　
//		この概念は実際にコードを書いたり、異なる例を試したりすることで徐々に理解が深まります。
//		
//		
		
		
//		2日目
//		3、条件分岐
		
		//比較演算子
//		
//		・論理演算子
//		
//	　演算子　　　　　意味　　　   例　　　　　説明
//		&　　　　　　論理積　 　 a & b       aとbが両方ともtrueの場合にtrue
//		|          論理和     a | b        aかbの少なくとも1つがtrueの場合にtrue
//		!   　   　 否定		  ！a         aがtrueの場合にfalseの場合にtrue
//		
//		論理積は「AかつB」という条件を表現する。
		
//		・左辺と右辺の組み合わせと演算の結果（AND演算）
//		
//		左辺　　　右辺　　　　結果
//		true     true     true
//		true      false     false
//		false     false    false
//		→　両方ともtrueの時だけtrueを戻す。
//		
//		・左辺と右辺の組み合わせと演算の結果（OR演算）
//
//		左辺　　　右辺　　　　結果
//		true     true     true
//		true      false    true
//		false     false    false
//		→　両方ともfalseの時だけfalseを戻す。
//
		
//		int a = 1;
//		int i = 4;
//		if (a == 1 | i++ < 5) {
//			//do something
//		}
//		System.outprintln(i);
//		
//		条件文でビット単位のOR（|）を使用していますが、
//		論理的なOR（||）と混同されているようです。
//		ビット単位のOR演算子はショートサーキット（短絡評価）を行わないため、
//		左側の演算がtrueであっても右側の演算が評価されます。
//		一方、論理的なOR演算子はショートサーキットを行います。
//		変数の初期値は以下の通りです：
//		a = 1   i = 4
//		if文の条件はa == 1 | i++ < 5です。この条件を詳しく見てみましょう：
//		a == 1はtrueに評価されます。
//		i++ < 5もtrueに評価されますが、i++のため、iの値は1増加します。
//		ビット単位のOR演算子が使用されているため、両方の条件が評価され、
//		最初の条件がOR操作を満たしていてもiは増加します。
//		if文の後、iの値は5になります。
//		なぜなら、条件i++ < 5がiをインクリメントするからです。
		//→　System.out.println(i);を実行すると、出力は5になります。
		

//		
//		int a = 1;
//		int i = 4;
//		if (a == 1 || i++ < 5) {
//			//do something
//		}
//		System.outprintln(i);
//		
//		コードがJavaで書かれていることを踏まえると、
//		今回の`if`文では論理的なOR（`||`）が使用されています。
//		論理的なOR演算子は、最初の条件が`true`に評価された場合、
//		ショートサーキット（短絡評価）を発生させ、二番目の条件の評価をスキップします。
//
//		変数の初期値は以下の通りです：
//		- `a = 1`
//		- `i = 4`
//
//		そして、`if`文の条件は`a == 1 || i++ < 5`です。
//		この条件を分解してみましょう：
//
//		1. `a == 1`は`true`に評価されます。
//		2. `||`（論理的なOR）が使用されているため、
//		最初の条件が`true`に評価されると、
//		二番目の条件`i++ < 5`は評価されません。
//		これは、論理的なOR演算子がショートサーキットの動作をするためです。
//
//		したがって、`i`の値は増加せず、4のままです。
//
//		その結果、`System.out.println(i);`を実行すると、出力は`4`になります。
//		
//		ショートサーキット演算子は、論理演算子の「&」や「|」を2つ重ねて記述する。
//		・AND演算・・・「&&」と記述し左辺がfalseを戻す場合は右辺の演算を省略
//		・OR演算・・・「||」と記述し、左辺がtrueを戻す場合は右辺の演算を省略
		
//		int a = 1;
//		int i = 4;
//		i++;
//		if (a == 1 || i++ < 5) {
//		}
//		System.outprintln(i);
//		
//		このJavaのコードでは、`if`文の前に`i`の値を
//		インクリメント（`i++`）しています。それから、
//		論理的なOR（`||`）を使用した条件を評価しています。
//		ショートサーキットの原理に従い、最初の条件が`true`の場合、二番目の条件は評価されません。
//		ステップごとに見てみましょう：
//		1. `a = 1`
//		2. `i = 4` から始まり、`i++`によって`i`は5にインクリメントされます。
//		3. `if`文の条件`a == 1 || i++ < 5`に進みますが、
//		最初の部分`a == 1`が`true`に評価されるため、
//		論理的なORの二番目の条件`i++ < 5`は評価されません。
//		この時点で`i`は既に5です。
//		4. `System.out.println(i);`を実行します。
//		この時点で、`i`の値は5です。`if`文内の条件`i++ < 5`は評価されないため、
//		`i`の値はさらに増加しません。
//		したがって、`System.out.println(i);`の出力は`5`になります。
//		
//		
//		
//		
//		①
//		int a = 1;
//		int i = 4;
//		if (a == 1 || i++ < 5) {
//		}
//		System.outprintln(i);
//		→4
//		なのに
//		
//		②
//		int a = 1;
//		int i = 4;
//		i++;
//		if (a == 1 || i++ < 5) {
//		}
//		System.outprintln(i);
//		→5になるのですか？
//		
//		
//		①if文の条件はa == 1 || i++ < 5です。ここでa == 1がtrueに評価されるため、
//		i++ < 5の部分は評価されず、iの値は変化しません。
//		そのため、System.out.println(i);の出力は4になります。
//		
//		②if文の前にiをインクリメントしてiの値が5になります。その後、
//		if文の条件a == 1 || i++ < 5を評価しますが、ここでもa == 1がtrueに評価されるため、
//		i++ < 5の評価はスキップされます。その結果、
//		iの値はif文の条件による変更を受けず、インクリメントされた後の値5がそのまま保持されます。
//		したがって、System.out.println(i);の出力は5になります。

		
//		
//
//public class Main {
//	public static void main(String[] args) {
//		int num = 10;
//		int resuit = num++ % 4;
//		System.out.println(resuit);
//		
//	}
//}
//
//どうして
//int resuit = num++ % 4;　　
//11割る4の余りではなく10割る4の余りなのでしょうか
//　　num++なのでnumは11ではないのですか。
//  
//→
//このコードにおける `num++ % 4` の操作を理解するには、
//Javaにおけるインクリメント演算子 `++` の挙動を知る必要があります。
//インクリメント演算子には二つの形式があります：
//`num++`（後置インクリメント）と`++num`（前置インクリメント）です。
//
//- **後置インクリメント** (`num++`) の場合、
//式の評価（この場合は `% 4` の計算）が行われた後に変数の値が1増加します。
//つまり、`num++` を `% 4` で割る操作が先に行われ、
//その結果が `result` に代入された後で `num` の値が1増加します。
//
//- **前置インクリメント** (`++num`) の場合、
//変数の値が1増加した後で、その新しい値を使って式が評価されます。
//
//このコード片では、`num++` を使用していますので、後置インクリメントが適用されます。
//`num` の初期値は10ですので、`num++ % 4` の操作は
//まず `10 % 4` の計算が行われ（この結果は2）、その後で `num` の値が11に増加します。
//
//したがって、`result` に代入される値は2になります。
//この操作後、`num` の値は11になりますが、
//`result` への代入が先に行われるため、計算結果としては `10 % 4` の結果が使用されます。
//
//このように、`num++ % 4` は `num` が11になる前に計算されるため、
//10を4で割った余りが結果として得られます。

//		
//		→自己理解
//		書き方が違うから
//		int resuit = num++ % 4;　のnum++は後で11になるのか。
//		10割る4のあまりは2なので2が表示され後でnum++は11になるのかも。
		
		
//		2日目のおさらい
//		Q5. 次のコードを実行した時にAからEのうち表示されないものh？
////		
//		int val = 10;
//		if ( 0 < val) {
//			if (val < 100) {
//				System.out.println("A");
//			}
//			System.out.println("B");
//		} else if (10 <= val) {
//			System.out.println("C");
//		} else {
//			System.out.println("D")
//		}
//		System.out.println("E")
//		
//		→
//		A
//		B
//		E
//
//		ここでの処理の流れは以下の通りです：
//
//		1. `val` には10が代入されています。
//		2. 最初の `if` ステートメント (`if (0 < val)`) は `val` が0より
//		大きいかを評価します。10は0より大きいため、この条件は `true` になります。
//		3. 次に、ネストされた `if` ステートメント (`if (val < 100)`) が評価されます。
//		`val` は100より小さいので、この条件も `true` になり、"A" が出力されます。
//		4. ネストされた `if` ステートメントの後にある `System.out.println("B");` は、
//		最初の `if` ブロック内にあるため、常に実行されます。
//		そのため、"B" も出力されます。
//		5. 最初の `if` ステートメントが `true` であるため、
//		`else if` と `else` のブロックは無視されます。
//		6. 最後に、`System.out.println("E");` が実行され、"E" が出力されます。
//
//		`else if (10 <= val)` のブロックは評価されません。
//		なぜなら、最初の `if` 条件が既に `true` であったため、
//		その `if-else` チェーンはそこで終了するからです。
//		Javaでは、`if-else` チェーンの中で最初に
//		`true` になったブロックだけが実行され、残りは無視されます。

		
		//3日目
		//4,繰り返し構文
		
		明日復習したいとこ
		p106〜
		chatGTPに質問
		
		
		
		
		
		
		
		
		
		SE/プログラマーを目指すための「プログラミング（Java）学習」
		【入門 #7】まで視聴完了
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}