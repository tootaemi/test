package test;

public class Bronze {
	public static void main(String[] args) {
		//System.out.println("こんにちは。");
		

//		1日目
//		1、javaの概要
//		2、変数、データ型、演算子
		
//		
//		1-4 プログラミングを始める
//
//		字下げはTabキーを押す。スペースで字下げしない。
//		因みに、MacのタブキーはQの左隣
//		
//		1-5  javaのプログラムが動く仕組み
//		Point!
//		・コンパイルとはコンピュータがソースコードを理解できるように翻訳すること
//		・コンパイルするための翻訳プログラムのことを「コンパイラ」という
//		・コンパイラを2回行い2回目のコンパイルはプログラムの実行時にJVMを使ってマシン語に翻訳している。
//		
//		翻訳作業のことを「コンパイル」
//		翻訳前のコードを「ソースコード」
//		ソースコードをコンパイルするための翻訳プログラムのことを「コンパイラ」と呼ぶ。
//		
//		1-6 プログラムを構成するもの
//		point!
//		・1つのプログラム部品のことを「クラス」という。
//		・ブロックとはコードの塊を表す集合体のことで「{」から「}」で表す。
//		・コード中の命令のことを「ステートメント」
//		プログラムの実行中に扱うデータのことを「リテラル」　という。
//		
		//・数値　ダブルクォーテーション「”」なしで記述できる。
		//・文字列　　ダブルクォーテーション「”」で括らなければいけない
//		
//		「”」で括ることでデータ型であることを明確に示している。
//		
//		2,変数、データ型、演算子
//		point!
//		・変数名　人が理解しやすいようにメモリアドレスにつける別名のこと
//		・変数名を使って実際のメモリアドレスを参照し
//		そこにあるデータにアクセスできるようにする仕組みのことを「変数」という。
//		・8種類のプリミティブ型	（short型、byte型、long型、int型、double型、float型、char型、boolean型）
//		のデータ型が用意されている。
//		・変数は宣言したのちに初期化することによって使うことができるようになる。
//		
		
//		
//		データ型は、プリミティブ型、オブジェクト型、列挙型の３つに分類される。
//		最も基本となるプリミティブ型を学ぶ。
//		基本データ型　とも呼ばれる。
//		
//		プリミティブ型
//		省略
//		
//		文字列と文字の違い
//		・文字・・・1文字しか使えない。char型（データ型）
//		・文字列・・・何文字でも扱える。String型（データ型）
		
//		定数とは値を変更できない定数。
//		
//		2-2　算術演算子
		//point　　　省略
		
//		int a = 10;
//		System.out.println(a % 3);
//		
//		10を3で割ると、確かに商は約3.33333333...となりますが、
//		プログラミングにおける剰余演算子`%`は除算の結果の商ではなく、
//		余りを求めるものです。したがって、10を3で割った場合の余りは1となります。
//		この余りが`System.out.println(a % 3);`によって出力される値です。
		
		//インクリメント、デクリメント
//		int a = 10;
//		int b = a++;
//		int c = ++a;
//		System.out.println(b);
//		System.out.println(c);
//
//		このJavaのコードは、`a`の値をインクリメント（1増加）しながら、
//		変数`b`と`c`に代入する操作を行っています。
//
//		1. `int a = 10;` で、変数`a`に10が代入されます。
//		2. `int b = a++;` で、`a`の現在の値（10）が`b`に代入された後、
//		`a`の値が1増加して11になります。ポストインクリメント演算子`a++`は、
//		値を代入した後にインクリメント（1増加）を行います。
//		3. `int c = ++a;` では、`a`の値が先に1増加して12になり、
//		その後で`c`に代入されます。プレインクリメント演算子`++a`は、
//		インクリメントを先に行い、その後で値を代入します。
//		したがって、最終的な出力は以下の通りです。
//		bの出力: 10
//		cの出力: 12
//		`b`は`a`がインクリメントされる前の値を保持し、
//		`c`は`a`が2回インクリメントされた後の値を保持します。
//		
//		iong a = 1;
//		int b = (int) a;
////		
//		大きい型から小さい型への変換はキャストしないとコンパイルエラーになる。
//		キャストを「明示的な型変換」と呼ぶ。
//		
//		→
//		「キャスト」とは、プログラミングにおいて、あるデータ型の変数や値を
//		別のデータ型に明示的に変換する操作のことを指します。
//		特に、「大きい型から小さい型への変換」の場合、このキャスト操作は必須となります。
//		これは、変換を試みる値が新しい型で扱える範囲外の可能性があるため、
//		プログラマがその変換の意図を明示的に示す必要があるからです。
//
//		例えば、`long`型（64ビット整数）から`int`型（32ビット整数）への変換では、
//		`long`型の範囲は`int`型のそれより広いため、
//		変換過程で値が`int`型の範囲に収まらない可能性があります。
//		このような場合、キャスト（型変換）を明示的に行うことで、
//		プログラマは意図的に範囲を狭め、情報の損失を受け入れていることをコンパイラに伝えます。
//
//		キャストの基本的な文法は、変換先の型を括弧`()`で囲み、
//		その後に変換したい変数や値を記述します。
//		例えば、`long`型の変数`a`を`int`型に変換する場合、以下のように書きます。
//
//		long a = 10000000000L;
//		int b = (int) a; // aをint型にキャストする
//
//		この操作により、`a`の値が`int`型の変数`b`に代入されますが、
//		もし`a`の値が`int`型で表現できる範囲を超えている場合、
//		結果は予測不可能（通常は値のトランケートが行われますが、正確な結果は言語や実装に依存します）
//		になり得るため、キャストを行う際には注意が必要です。
		
		
//		このコードスニペットには、`long`型の変数`a`を宣言し、
//		その値を`int`型の変数`b`にキャスト（型変換）しています。
//		ただし、コードの最初の行に「`iong`」というタイプミスがあり、
//		正しくは「`long`」です。正しく修正すると以下のようになります。
//
//		long a = 1;
//		int b = (int) a;
//
//		ここで、`long a = 1;`は`a`という名前の`long`型変数を宣言し、
//		それに1を代入しています。`long`型は64ビットの整数値を保持でき、
//		`int`型よりも大きな値を扱うことができます。
//
//		次に、`int b = (int) a;`は`a`の値を`int`型にキャストしています。
//		このキャストは、`long`型から`int`型への明示的な型変換を示しています。
//		この場合、`a`の値は1であり、`int`型の範囲内に収まるため、
//		変換は問題なく行われ、`b`は1という値を保持します。
//		型変換（キャスト）を使うことで、異なる型の値間での代入が可能になりますが、
//		元の値が新しい型で扱える範囲を超える場合、情報の損失が発生する可能性があります。
//		この例では、`long`型の値が`int`型で扱える範囲内にあるため、情報の損失はありません。
//		
//		
//		・小さい型から大きい型へはコンパイラが自動的に変換する・・・暗黙の型変換
//		・大きい型から小さい型へはプログラマーがキャストする。・・・明示的な
//		
//		※　キャストとはデータ型を変換すること。
//		特に明示的に変換するときキャストと呼ぶことが多い
		
//		
//		1日目のおさらい
//		問題　1
//		⇨　C
//		
//		問題　2
//		int num = 10;
//		int resuit = num++ % 4;
//		System.out.println(resuit);
//		
//		⇨　10を4で割った余りを求める
//		10割る4は2.5ですよね。
//		なので余らないと思うのですが
//		どう考えたらいいのでしょうか
//		
//		整数の割り算の場合、結果は整数部分のみとなり、小数点以下は無視されます。
//		したがって、10を4で割ると、結果は2になります（商は2）。
//		小数点以下の部分（0.5）は割り算の結果には含まれず、
//		剰余演算子`%`を使用した場合には余りとして扱われます。
//		この場合、10を4で割った余りは2になります。
//		整数の割り算では、商と余りを別々に考える必要があります。
//		商は整数部分のみで、余りは割り算で割り切れなかった部分です。
//		
//		10を4で割った場合、商は2で余りは2です。
//		割り算を行う際、特にプログラミングにおいて整数同士の除算では、
//		結果は整数部分のみを返し、小数点以下は無視されます。
//		ですので、10を4で割ると、商は2になり、余りは2です。
//		剰余演算子`%`はこの余りを求めるものです。
//		コードの説明において、あなたが言及している「10割る4は2.5ですよね。
//		なので余らない」というのは、割り算の結果を小数で表した場合の理解です。
//		しかし、剰余演算では小数点以下は考慮されず、
//		整数の割り算での余り（この場合は2）が結果として返されます。
//		したがって、
//		
//		int num = 10;
//		int result = num++ % 4;
//		System.out.println(result);
//		
//		は以下のように動作します。
//
//		1. `num`に10が代入されます。
//		2. `num++ % 4`は、`num`の現在の値（10）を4で割った余りを計算し、
//		その後`num`の値を1増やします。10を4で割った余りは2なので、
//		`result`には2が代入されます。
//		3. `System.out.println(result);`により、
//		`result`の値である2が出力されます。
//
//		結果的に、このコードは`2`を出力します。
//		
//		
//		
//		`num++`という表現は、"ポストインクリメント"演算子を使用しています。
//		これは、変数`num`の現在の値を使用した後、
//		その値を1増加させるという操作を意味します。したがって、`num++`が式内で使われるとき、まず`num`の現在の値（この場合は10）が式に使用され、その後`num`の値が1増加して11になります。
//
//		このコンテキストでの`int result = num++ % 4;`という行は、
//		以下の手順で実行されます：
//
//		1. `num`の現在の値（10）を取得します。
//		2. 取得した値（10）を4で割った余りを計算します。この余りは2です。
//		3. `result`変数に余り（2）を代入します。
//		4. `num`の値を1増加させ、`num`は11になります。
//
//		したがって、`System.out.println(result);`の出力は`2`になりますが、
//		その直後で`num`の値を確認すると、`num`は11になっています。
//		
//		
//		
//		int num = 10;
//		int result = num++ % 4;　　num++ 　は11ではないのですか
//		
//		それなら11割る4ですよね？　11割る4は2.75なのであまりが分からないです
//
//
//		
//		`num++ % 4`の操作についての混乱を解消しましょう。
//		この式では、`num++`が使用されているため、`num`の値は式の評価後に1増加しますが、
//		式の評価に使われるのは増加前の値です。
//		つまり、`num`が10のとき、`num++ % 4`の計算では10が使われ、
//		その後`num`は11になりますが、この計算での除算は`10 % 4`が行われます。
//
//		`11 % 4`についてのご質問ですが、実際に式で使用されているのは`10 % 4`です。
//		しかし、`11 % 4`の計算についても説明しますね。
//		11を4で割った場合の商は2で、余りは3です。整数の割り算では、結果は整数で表され、
//		割り算の余りは`%`演算子で求められます。したがって、11を4で割った余りは3になります。
//
//		要点を整理すると、`num++ % 4`の計算では
//		`num`の増加前の値（10）が使われ、10を4で割った余り、つまり2が`result`に代入されます。
//		その後、`num`の値は11になりますが、
//		この時点での`num`の値は`result`の計算には影響しません。
		

//		
//		ポストインクリメント（`num++`）のような操作は特に、実際にいくつかの例を通して
//		学んでいくと理解が深まります。以下に、ポストインクリメントの概念を
//		もう少し簡単に説明します。
//
//		### ポストインクリメント (`num++`)
//		- **動作**: 変数の現在の値を使用してから、その値を1増加させます。
//		- **例**: `num`が10の場合、`num++`の操作を行うと、
//		まず`num`の現在の値（10）が使用され、その操作が完了した後に
//		`num`は11になります。
//
//		### 例による説明
//		1. **初期状態**: `int num = 10;`
//		2. **操作**: `int result = num++ % 4;`
//		   - `num`の値（10）を取り、4で割った余りを計算します。10 % 4 = 2。
//		   - `result`には2が代入されます。
//		   - この操作の後、`num`の値は1増加して11になります。
//		3. **結果**: `System.out.println(result);`を実行すると、
//		`2`が出力されます。この時点で`num`の値は11です。
//
//		ポストインクリメントは、その行での値の使用後に増加が行われるため
//		、増加が行われる前の値がその行の操作に使用されます。
//		この概念は実際にコードを書いたり、異なる例を試したりすることで徐々に理解が深まります。
//		
//		
		
		
//		2日目
//		3、条件分岐
		
		//比較演算子
//		
//		・論理演算子
//		
//		演算子　　　　意味　　　   例　　　　　　　　　説明
//		&　　　　　論理積　 　 a & b        　aとbが両方ともtrueの場合にtrue
//		|         　論理和     a | b       aかbの少なくとも1つがtrueの場合にtrue
//		!   　   　　否定		 ！a          aがtrueの場合にfalseの場合にtrue
//		
//		論理積は「AかつB」という条件を表現する。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}