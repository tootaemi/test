package test;

public class Bronze {
	public static void main(String[] args) {
//		System.out.println("こんにちは。");
		

//		1日目
//		1、javaの概要
//		2、変数、データ型、演算子
		
//		
//		1-4 プログラミングを始める
//
//		字下げはTabキーを押す。スペースで字下げしない。
//		因みに、MacのタブキーはQの左隣
//		
//		1-5  javaのプログラムが動く仕組み
//		Point!
//		・コンパイルとはコンピュータがソースコードを理解できるように翻訳すること
//		・コンパイルするための翻訳プログラムのことを「コンパイラ」という
//		・コンパイラを2回行い2回目のコンパイルはプログラムの実行時にJVMを使ってマシン語に翻訳している。
//		
//		翻訳作業のことを「コンパイル」
//		翻訳前のコードを「ソースコード」
//		ソースコードをコンパイルするための翻訳プログラムのことを「コンパイラ」と呼ぶ。
//		
//		1-6 プログラムを構成するもの
//		point!
//		・1つのプログラム部品のことを「クラス」という。
//		・ブロックとはコードの塊を表す集合体のことで「{」から「}」で表す。
//		・コード中の命令のことを「ステートメント」
//		プログラムの実行中に扱うデータのことを「リテラル」　という。
//		
		//・数値　ダブルクォーテーション「”」なしで記述できる。
		//・文字列　　ダブルクォーテーション「”」で括らなければいけない
//		
//		「”」で括ることでデータ型であることを明確に示している。
//		
//		2,変数、データ型、演算子
//		point!
//		・変数名　人が理解しやすいようにメモリアドレスにつける別名のこと
//		・変数名を使って実際のメモリアドレスを参照し
//		そこにあるデータにアクセスできるようにする仕組みのことを「変数」という。
//		・8種類のプリミティブ型	（short型、byte型、long型、int型、double型、float型、char型、boolean型）
//		のデータ型が用意されている。
//		・変数は宣言したのちに初期化することによって使うことができるようになる。
//		
		
//		
//		データ型は、プリミティブ型、オブジェクト型、列挙型の３つに分類される。
//		最も基本となるプリミティブ型を学ぶ。
//		基本データ型　とも呼ばれる。
//		
//		プリミティブ型
//		省略
//		
//		文字列と文字の違い
//		・文字・・・1文字しか使えない。char型（データ型）
//		・文字列・・・何文字でも扱える。String型（データ型）
		
//		定数とは値を変更できない定数。
//		
//		2-2　算術演算子
		//point　　　省略
		
//		int a = 10;
//		System.out.println(a % 3);
//		
//		10を3で割ると、確かに商は約3.33333333...となりますが、
//		プログラミングにおける剰余演算子`%`は除算の結果の商ではなく、
//		余りを求めるものです。したがって、10を3で割った場合の余りは1となります。
//		この余りが`System.out.println(a % 3);`によって出力される値です。
		
		//インクリメント、デクリメント
//		int a = 10;
//		int b = a++;
//		int c = ++a;
//		System.out.println(b);
//		System.out.println(c);
//
//		このJavaのコードは、`a`の値をインクリメント（1増加）しながら、
//		変数`b`と`c`に代入する操作を行っています。
//
//		1. `int a = 10;` で、変数`a`に10が代入されます。
//		2. `int b = a++;` で、`a`の現在の値（10）が`b`に代入された後、
//		`a`の値が1増加して11になります。ポストインクリメント演算子`a++`は、
//		値を代入した後にインクリメント（1増加）を行います。
//		3. `int c = ++a;` では、`a`の値が先に1増加して12になり、
//		その後で`c`に代入されます。プレインクリメント演算子`++a`は、
//		インクリメントを先に行い、その後で値を代入します。
//		したがって、最終的な出力は以下の通りです。
//		bの出力: 10
//		cの出力: 12
//		`b`は`a`がインクリメントされる前の値を保持し、
//		`c`は`a`が2回インクリメントされた後の値を保持します。
//		
//		iong a = 1;
//		int b = (int) a;
////		
//		大きい型から小さい型への変換はキャストしないとコンパイルエラーになる。
//		キャストを「明示的な型変換」と呼ぶ。
//		
//		→
//		「キャスト」とは、プログラミングにおいて、あるデータ型の変数や値を
//		別のデータ型に明示的に変換する操作のことを指します。
//		特に、「大きい型から小さい型への変換」の場合、このキャスト操作は必須となります。
//		これは、変換を試みる値が新しい型で扱える範囲外の可能性があるため、
//		プログラマがその変換の意図を明示的に示す必要があるからです。
//
//		例えば、`long`型（64ビット整数）から`int`型（32ビット整数）への変換では、
//		`long`型の範囲は`int`型のそれより広いため、
//		変換過程で値が`int`型の範囲に収まらない可能性があります。
//		このような場合、キャスト（型変換）を明示的に行うことで、
//		プログラマは意図的に範囲を狭め、情報の損失を受け入れていることをコンパイラに伝えます。
//
//		キャストの基本的な文法は、変換先の型を括弧`()`で囲み、
//		その後に変換したい変数や値を記述します。
//		例えば、`long`型の変数`a`を`int`型に変換する場合、以下のように書きます。
//
//		long a = 10000000000L;
//		int b = (int) a; // aをint型にキャストする
//
//		この操作により、`a`の値が`int`型の変数`b`に代入されますが、
//		もし`a`の値が`int`型で表現できる範囲を超えている場合、
//		結果は予測不可能（通常は値のトランケートが行われますが、正確な結果は言語や実装に依存します）
//		になり得るため、キャストを行う際には注意が必要です。
		
		
//		このコードスニペットには、`long`型の変数`a`を宣言し、
//		その値を`int`型の変数`b`にキャスト（型変換）しています。
//		ただし、コードの最初の行に「`iong`」というタイプミスがあり、
//		正しくは「`long`」です。正しく修正すると以下のようになります。
//
//		long a = 1;
//		int b = (int) a;
//
//		ここで、`long a = 1;`は`a`という名前の`long`型変数を宣言し、
//		それに1を代入しています。`long`型は64ビットの整数値を保持でき、
//		`int`型よりも大きな値を扱うことができます。
//
//		次に、`int b = (int) a;`は`a`の値を`int`型にキャストしています。
//		このキャストは、`long`型から`int`型への明示的な型変換を示しています。
//		この場合、`a`の値は1であり、`int`型の範囲内に収まるため、
//		変換は問題なく行われ、`b`は1という値を保持します。
//		型変換（キャスト）を使うことで、異なる型の値間での代入が可能になりますが、
//		元の値が新しい型で扱える範囲を超える場合、情報の損失が発生する可能性があります。
//		この例では、`long`型の値が`int`型で扱える範囲内にあるため、情報の損失はありません。
//		
//		
//		・小さい型から大きい型へはコンパイラが自動的に変換する・・・暗黙の型変換
//		・大きい型から小さい型へはプログラマーがキャストする。・・・明示的な
//		
//		※　キャストとはデータ型を変換すること。
//		特に明示的に変換するときキャストと呼ぶことが多い
		
//		
//		1日目のおさらい
//		問題　1
//		⇨　C
//		
//		問題　2
//		int num = 10;
//		int resuit = num++ % 4;
//		System.out.println(resuit);
//		
//		⇨　10を4で割った余りを求める
//		10割る4は2.5ですよね。
//		なので余らないと思うのですが
//		どう考えたらいいのでしょうか
//		
//		整数の割り算の場合、結果は整数部分のみとなり、小数点以下は無視されます。
//		したがって、10を4で割ると、結果は2になります（商は2）。
//		小数点以下の部分（0.5）は割り算の結果には含まれず、
//		剰余演算子`%`を使用した場合には余りとして扱われます。
//		この場合、10を4で割った余りは2になります。
//		整数の割り算では、商と余りを別々に考える必要があります。
//		商は整数部分のみで、余りは割り算で割り切れなかった部分です。
//		
//		10を4で割った場合、商は2で余りは2です。
//		割り算を行う際、特にプログラミングにおいて整数同士の除算では、
//		結果は整数部分のみを返し、小数点以下は無視されます。
//		ですので、10を4で割ると、商は2になり、余りは2です。
//		剰余演算子`%`はこの余りを求めるものです。
//		コードの説明において、あなたが言及している「10割る4は2.5ですよね。
//		なので余らない」というのは、割り算の結果を小数で表した場合の理解です。
//		しかし、剰余演算では小数点以下は考慮されず、
//		整数の割り算での余り（この場合は2）が結果として返されます。
//		したがって、
//		
//		int num = 10;
//		int result = num++ % 4;
//		System.out.println(result);
//		
//		は以下のように動作します。
//
//		1. `num`に10が代入されます。
//		2. `num++ % 4`は、`num`の現在の値（10）を4で割った余りを計算し、
//		その後`num`の値を1増やします。10を4で割った余りは2なので、
//		`result`には2が代入されます。
//		3. `System.out.println(result);`により、
//		`result`の値である2が出力されます。
//
//		結果的に、このコードは`2`を出力します。
//		
//		
//		
//		`num++`という表現は、"ポストインクリメント"演算子を使用しています。
//		これは、変数`num`の現在の値を使用した後、
//		その値を1増加させるという操作を意味します。したがって、`num++`が式内で使われるとき、まず`num`の現在の値（この場合は10）が式に使用され、その後`num`の値が1増加して11になります。
//
//		このコンテキストでの`int result = num++ % 4;`という行は、
//		以下の手順で実行されます：
//
//		1. `num`の現在の値（10）を取得します。
//		2. 取得した値（10）を4で割った余りを計算します。この余りは2です。
//		3. `result`変数に余り（2）を代入します。
//		4. `num`の値を1増加させ、`num`は11になります。
//
//		したがって、`System.out.println(result);`の出力は`2`になりますが、
//		その直後で`num`の値を確認すると、`num`は11になっています。
//		
//		
//		
//		int num = 10;
//		int result = num++ % 4;　　num++ 　は11ではないのですか
//		
//		それなら11割る4ですよね？　11割る4は2.75なのであまりが分からないです
//
//
//		
//		`num++ % 4`の操作についての混乱を解消しましょう。
//		この式では、`num++`が使用されているため、`num`の値は式の評価後に1増加しますが、
//		式の評価に使われるのは増加前の値です。
//		つまり、`num`が10のとき、`num++ % 4`の計算では10が使われ、
//		その後`num`は11になりますが、この計算での除算は`10 % 4`が行われます。
//
//		`11 % 4`についてのご質問ですが、実際に式で使用されているのは`10 % 4`です。
//		しかし、`11 % 4`の計算についても説明しますね。
//		11を4で割った場合の商は2で、余りは3です。整数の割り算では、結果は整数で表され、
//		割り算の余りは`%`演算子で求められます。したがって、11を4で割った余りは3になります。
//
//		要点を整理すると、`num++ % 4`の計算では
//		`num`の増加前の値（10）が使われ、10を4で割った余り、つまり2が`result`に代入されます。
//		その後、`num`の値は11になりますが、
//		この時点での`num`の値は`result`の計算には影響しません。
		

//		
//		ポストインクリメント（`num++`）のような操作は特に、実際にいくつかの例を通して
//		学んでいくと理解が深まります。以下に、ポストインクリメントの概念を
//		もう少し簡単に説明します。
//
//		### ポストインクリメント (`num++`)
//		- **動作**: 変数の現在の値を使用してから、その値を1増加させます。
//		- **例**: `num`が10の場合、`num++`の操作を行うと、
//		まず`num`の現在の値（10）が使用され、その操作が完了した後に
//		`num`は11になります。
//
//		### 例による説明
//		1. **初期状態**: `int num = 10;`
//		2. **操作**: `int result = num++ % 4;`
//		   - `num`の値（10）を取り、4で割った余りを計算します。10 % 4 = 2。
//		   - `result`には2が代入されます。
//		   - この操作の後、`num`の値は1増加して11になります。
//		3. **結果**: `System.out.println(result);`を実行すると、
//		`2`が出力されます。この時点で`num`の値は11です。
//
//		ポストインクリメントは、その行での値の使用後に増加が行われるため
//		、増加が行われる前の値がその行の操作に使用されます。　
//		この概念は実際にコードを書いたり、異なる例を試したりすることで徐々に理解が深まります。
//		
//		
		
		
//		2日目
//		3、条件分岐
		
		//比較演算子
//		
//		・論理演算子
//		
//	　演算子　　　　　意味　　　   例　　　　　説明
//		&　　　　　　論理積　 　 a & b       aとbが両方ともtrueの場合にtrue
//		|          論理和     a | b        aかbの少なくとも1つがtrueの場合にtrue
//		!   　   　 否定		  ！a         aがtrueの場合にfalseの場合にtrue
//		
//		論理積は「AかつB」という条件を表現する。
		
//		・左辺と右辺の組み合わせと演算の結果（AND演算）
//		
//		左辺　　　右辺　　　　結果
//		true     true     true
//		true      false     false
//		false     false    false
//		→　両方ともtrueの時だけtrueを戻す。
//		
//		・左辺と右辺の組み合わせと演算の結果（OR演算）
//
//		左辺　　　右辺　　　　結果
//		true     true     true
//		true      false    true
//		false     false    false
//		→　両方ともfalseの時だけfalseを戻す。
//
		
//		int a = 1;
//		int i = 4;
//		if (a == 1 | i++ < 5) {
//			//do something
//		}
//		System.outprintln(i);
//		
//		条件文でビット単位のOR（|）を使用していますが、
//		論理的なOR（||）と混同されているようです。
//		ビット単位のOR演算子はショートサーキット（短絡評価）を行わないため、
//		左側の演算がtrueであっても右側の演算が評価されます。
//		一方、論理的なOR演算子はショートサーキットを行います。
//		変数の初期値は以下の通りです：
//		a = 1   i = 4
//		if文の条件はa == 1 | i++ < 5です。この条件を詳しく見てみましょう：
//		a == 1はtrueに評価されます。
//		i++ < 5もtrueに評価されますが、i++のため、iの値は1増加します。
//		ビット単位のOR演算子が使用されているため、両方の条件が評価され、
//		最初の条件がOR操作を満たしていてもiは増加します。
//		if文の後、iの値は5になります。
//		なぜなら、条件i++ < 5がiをインクリメントするからです。
		//→　System.out.println(i);を実行すると、出力は5になります。
		

//		
//		int a = 1;
//		int i = 4;
//		if (a == 1 || i++ < 5) {
//			//do something
//		}
//		System.outprintln(i);
//		
//		コードがJavaで書かれていることを踏まえると、
//		今回の`if`文では論理的なOR（`||`）が使用されています。
//		論理的なOR演算子は、最初の条件が`true`に評価された場合、
//		ショートサーキット（短絡評価）を発生させ、二番目の条件の評価をスキップします。
//
//		変数の初期値は以下の通りです：
//		- `a = 1`
//		- `i = 4`
//
//		そして、`if`文の条件は`a == 1 || i++ < 5`です。
//		この条件を分解してみましょう：
//
//		1. `a == 1`は`true`に評価されます。
//		2. `||`（論理的なOR）が使用されているため、
//		最初の条件が`true`に評価されると、
//		二番目の条件`i++ < 5`は評価されません。
//		これは、論理的なOR演算子がショートサーキットの動作をするためです。
//
//		したがって、`i`の値は増加せず、4のままです。
//
//		その結果、`System.out.println(i);`を実行すると、出力は`4`になります。
//		
//		ショートサーキット演算子は、論理演算子の「&」や「|」を2つ重ねて記述する。
//		・AND演算・・・「&&」と記述し左辺がfalseを戻す場合は右辺の演算を省略
//		・OR演算・・・「||」と記述し、左辺がtrueを戻す場合は右辺の演算を省略
		
//		int a = 1;
//		int i = 4;
//		i++;
//		if (a == 1 || i++ < 5) {
//		}
//		System.outprintln(i);
//		
//		このJavaのコードでは、`if`文の前に`i`の値を
//		インクリメント（`i++`）しています。それから、
//		論理的なOR（`||`）を使用した条件を評価しています。
//		ショートサーキットの原理に従い、最初の条件が`true`の場合、二番目の条件は評価されません。
//		ステップごとに見てみましょう：
//		1. `a = 1`
//		2. `i = 4` から始まり、`i++`によって`i`は5にインクリメントされます。
//		3. `if`文の条件`a == 1 || i++ < 5`に進みますが、
//		最初の部分`a == 1`が`true`に評価されるため、
//		論理的なORの二番目の条件`i++ < 5`は評価されません。
//		この時点で`i`は既に5です。
//		4. `System.out.println(i);`を実行します。
//		この時点で、`i`の値は5です。`if`文内の条件`i++ < 5`は評価されないため、
//		`i`の値はさらに増加しません。
//		したがって、`System.out.println(i);`の出力は`5`になります。
//		
//		
//		
//		
//		①
//		int a = 1;
//		int i = 4;
//		if (a == 1 || i++ < 5) {
//		}
//		System.outprintln(i);
//		→4
//		なのに
//		
//		②
//		int a = 1;
//		int i = 4;
//		i++;
//		if (a == 1 || i++ < 5) {
//		}
//		System.outprintln(i);
//		→5になるのですか？
//		
//		
//		①if文の条件はa == 1 || i++ < 5です。ここでa == 1がtrueに評価されるため、
//		i++ < 5の部分は評価されず、iの値は変化しません。
//		そのため、System.out.println(i);の出力は4になります。
//		
//		②if文の前にiをインクリメントしてiの値が5になります。その後、
//		if文の条件a == 1 || i++ < 5を評価しますが、ここでもa == 1がtrueに評価されるため、
//		i++ < 5の評価はスキップされます。その結果、
//		iの値はif文の条件による変更を受けず、インクリメントされた後の値5がそのまま保持されます。
//		したがって、System.out.println(i);の出力は5になります。

		
//		
//
//public class Main {
//	public static void main(String[] args) {
//		int num = 10;
//		int resuit = num++ % 4;
//		System.out.println(resuit);
//		
//	}
//}
//
//どうして
//int resuit = num++ % 4;　　
//11割る4の余りではなく10割る4の余りなのでしょうか
//　　num++なのでnumは11ではないのですか。
//  
//→
//このコードにおける `num++ % 4` の操作を理解するには、
//Javaにおけるインクリメント演算子 `++` の挙動を知る必要があります。
//インクリメント演算子には二つの形式があります：
//`num++`（後置インクリメント）と`++num`（前置インクリメント）です。
//
//- **後置インクリメント** (`num++`) の場合、
//式の評価（この場合は `% 4` の計算）が行われた後に変数の値が1増加します。
//つまり、`num++` を `% 4` で割る操作が先に行われ、
//その結果が `result` に代入された後で `num` の値が1増加します。
//
//- **前置インクリメント** (`++num`) の場合、
//変数の値が1増加した後で、その新しい値を使って式が評価されます。
//
//このコード片では、`num++` を使用していますので、後置インクリメントが適用されます。
//`num` の初期値は10ですので、`num++ % 4` の操作は
//まず `10 % 4` の計算が行われ（この結果は2）、その後で `num` の値が11に増加します。
//
//したがって、`result` に代入される値は2になります。
//この操作後、`num` の値は11になりますが、
//`result` への代入が先に行われるため、計算結果としては `10 % 4` の結果が使用されます。
//
//このように、`num++ % 4` は `num` が11になる前に計算されるため、
//10を4で割った余りが結果として得られます。

//		
//		→自己理解
//		書き方が違うから
//		int resuit = num++ % 4;　のnum++は後で11になるのか。
//		10割る4のあまりは2なので2が表示され後でnum++は11になるのかも。
		
		
//		2日目のおさらい
//		Q5. 次のコードを実行した時にAからEのうち表示されないものh？
////		
//		int val = 10;
//		if ( 0 < val) {
//			if (val < 100) {
//				System.out.println("A");
//			}
//			System.out.println("B");
//		} else if (10 <= val) {
//			System.out.println("C");
//		} else {
//			System.out.println("D")
//		}
//		System.out.println("E")
//		
//		→
//		A
//		B
//		E
//
//		ここでの処理の流れは以下の通りです：
//
//		1. `val` には10が代入されています。
//		2. 最初の `if` ステートメント (`if (0 < val)`) は `val` が0より
//		大きいかを評価します。10は0より大きいため、この条件は `true` になります。
//		3. 次に、ネストされた `if` ステートメント (`if (val < 100)`) が評価されます。
//		`val` は100より小さいので、この条件も `true` になり、"A" が出力されます。
//		4. ネストされた `if` ステートメントの後にある `System.out.println("B");` は、
//		最初の `if` ブロック内にあるため、常に実行されます。
//		そのため、"B" も出力されます。
//		5. 最初の `if` ステートメントが `true` であるため、
//		`else if` と `else` のブロックは無視されます。
//		6. 最後に、`System.out.println("E");` が実行され、"E" が出力されます。
//
//		`else if (10 <= val)` のブロックは評価されません。
//		なぜなら、最初の `if` 条件が既に `true` であったため、
//		その `if-else` チェーンはそこで終了するからです。
//		Javaでは、`if-else` チェーンの中で最初に
//		`true` になったブロックだけが実行され、残りは無視されます。

		
		//3日目
		//4,繰り返し構文
		
		//・二重ループ
//		for (int j = 0; j < 3; j++) {
//			System.out.println("*");
//			}
//		System.out.println();
//	}
		
//	forループを使用して、j変数を0から始め、3未満の間繰り返します。
//	各繰り返しでjの値は1ずつ増加します。
//	ループの内部で、System.out.println("*");が実行され、
//	コンソールにアスタリスク（*）を出力します。
//	ループが終了した後、System.out.println();が実行され、
//	コンソールに改行（空行）が出力されます。
//	結果として、コンソールにはアスタリスクが縦に3行出力され、
//	その後に空行が1行出力されます。
//		
//	for (int j = 0; j < 3; j++) {
//		のint j = 0;はjは0という意味。
//		「`int j = 0;`」という部分は、`j`という名前の
//		変数を整数（`int`）として宣言し、その初期値を0に設定しています。
//		この文は`for`ループの開始部分で使われ、
//		ループが開始する前に1回だけ実行されます。
//		ループの各繰り返しにおいて、`j`の値はループの条件部分
//		（この場合は`j < 3`）と更新部分（この場合は`j++`、`j`の値を1増加させる操作）に
//		基づいて制御されます。
//
//		具体的には、このコードの流れは以下のようになります：
//
//		1. `j`を0で初期化します。
//		2. `j < 3`の条件を評価します。もし`j`が3未満であれば、
//		ループの本体（ここでは`System.out.println("*");`）が実行されます。
//		3. ループの本体が実行された後、`j++`が実行され、`j`の値が1増加します。
//		4. 再び`j < 3`の条件を評価し、
//		条件が`true`であればループの本体を再び実行します。
//		`false`であれば、ループは終了します。
//
//		このプロセスを通じて、`j`は0から始まり、
//		1ずつ増加し、最終的に3未満の間ループが繰り返されます。
//
//		・二重ループの動作
//		jの値（外側）　　　iの値（内側）　　　　　動作
//		
//		 0               0             * を表示する
//		 0　　　　　　　　　1　　　　　　　　* を表示する
//		 0　　　　　　　　　2　　　　　　　　*を表示して内側のループを抜け改行する
//		 1               0              * を表示する
//		 1               1              * を表示する
//		 1               2             　*を表示して内側のループを抜け改行する
//		 2               0               *を表示する
//		 2               1               *を表示する
//		 2               2              　*を表示して内側のループを抜け改行する

		
////		3日目のおさらい
//		int total = 0;
//		for (int i = 3; 1 < i; i--) {
//			total += i;
//		}
//		System.out.println(total);		
//		
//
//		変数`total`を0で初期化し、
//		その後`for`ループを使って変数`i`を3から始めて
//		1より大きい間、`i`の値を1ずつ減少させながら、
//		`total`に`i`の値を加算していきます。最後に、`total`の値を出力します。
//
//		ループの条件`1 < i`は、`i`が1より大きい間ループを続けることを意味します。
//		したがって、`i`の初期値は3であり、ループの各繰り返しで`i`の値は1ずつ減少します。
//		これにより、`i`の値は3、2の順になり、`i`が1になるとループは停止します。
//
//		ループの各繰り返しで`total`に`i`の値を加算するため、次のような計算が行われます：
//
//		- 初期状態: `total = 0`
//		- 1回目の繰り返し: `total = 0 + 3 = 3`
//		- 2回目の繰り返し: `total = 3 + 2 = 5`
//
//		ループが終了した後、`total`の値は5となり、この値が出力されます。
//		したがって、このコードの実行結果は`5`となります。
//		
		
//		//Q3.
//		int i = 1;
//		do {
//			i = i + 1;
//		} while(i < 10);
//		System.out.println(i);
//		
//		このJavaのコードスニペットは、`do-while`ループを使用しています。
//		`do-while`ループは、ループの本体が最低一回は実行されることを保証します。
//		つまり、まず`do`ブロック内のコードが実行され、その後`while`の条件が評価されます。
//		条件が`true`である限り、ループは続けられます。
//
//		この具体的な例では、変数`i`が1で初期化され、
//		ループ内で`i`に1が加算され続け、
//		`i`が10未満である間ループが続きます。
//		ループの各繰り返しで`i`の値は1増加し、`i`が10以上になるとループは終了します。
//
//		ループが始まった時点で`i`の値は1です。
//		`do`ブロックが実行されるたびに、`i`に1が加算されます。
//		`i`が10になると、`while(i < 10)`の条件が`false`と評価され、
//		ループは終了します。最終的に、`System.out.println(i);`によって
//		`i`の値が出力されます。
//
//		このコードの実行結果は`i`の最終値、つまり`10`です。
//		これは、`i`が9から10に増加した後、
//		ループの条件が`false`と評価され、ループが終了するためです。
		
		
		//4日目
		//配列。　メソッド。
//		
//		配列型変数の宣言
//		[]　変数名;
//		
//		[]（角カッコ）がデータ型の宣言してる場所。
//		[] array;  　　　コンパイルエラーになる
//		
//		int[] array;
//		int型だけを扱う配列型変数のarrayを宣言する　という意味。
//		
//		int[] array = 10;  　←コンパイルエラー
//		
//		
//		配列型変数の宣言
//		制約[] 変数名;
//		
//		int[] array;    基本の書き方
//		int array[];　　　同じ意味
//		
//		
//		配列の作成
//		new 制約[要素数];
//		
//		new int[3];
//		int型の要素3つを扱う配列を作ってる。
//		
//		int[] array = new int[3];
//	　　　	↑　　　　　　　　　↑
//	配列型変数arrayの宣言　　　int型の要素3つを扱う配列の作成
//		
//	int array = new int[3];
//	　　　	
//	　　このJavaのコード行は、整数型の配列arrayを作成し、そのサイズを3に設定しています。
//	  しかし、正確にはarrayが配列を指す変数であるため、
//	  int[] arrayという記述が適切です。したがって、正しいコードは次のようになります：
//		
//	  int[] array = new int[3];
//	
//	このコードは、3つの整数を格納できる配列を初期化しています。
//	配列の各要素は、整数型のデフォルト値である0で初期化されます。
//	したがって、この配列arrayは、3つの要素を持ち、それぞれの要素の値は0です。
//	配列の要素には、インデックスを使ってアクセスでき、インデックスは0から始まります。
////	この場合、array[0]、array[1]、array[2]が配列の全ての要素になります。
//		
//		int[]array = new int[3];
//		array[0] = 10;
//		array[1] = 20;
//		array[2] = 30;
		
//		for (int i = 0; i < 3; i++) {
//			int val = array[i];
//			System.out.println(val);
//		}
//
//		このJavaのコードスニペットでは、
//		まず`int`型の要素を3つ持つ配列`array`を初期化しています。
//		その後、この配列の各要素に値を割り当てています：
//
//		- `array[0]`には`10`を割り当てます。
//		- `array[1]`には`20`を割り当てます。
//		- `array[2]`には`30`を割り当てます。
//
//		これにより、配列`array`は整数の列`10, 20, 30`を保持します。
//
//		その後、`for`ループを使用して配列の各要素を順にアクセスし、
//		その値を変数`val`に代入しています。
//		ループ内で、`System.out.println(val);`を使用して、
//		変数`val`の値（つまり配列の各要素の値）をコンソールに出力します。
//
//		このコードを実行すると、以下のように配列の各要素が順番に出力されます：
//
//		```
//		10
//		20
//		30
//		```
//
//		これは、配列`array`の要素が順に出力されるためです。
//		`for`ループは、`i`が`0`から始まり、`i < 3`の条件が`true`である間
//		（つまり`i`が`0`、`1`、`2`の場合）、
//		各繰り返しで`i`の値を1増加させることで配列の各要素にアクセスしています。
//
//		
//		拡張for文
//		for (　データ型　変数名　：　集合) {
//			繰り返し処理
//		}
//		
//		
//		メソッド
//		
//		p171まで読み終わり、
//		p172〜スタート
//		
//		
//		System.out.println("A");
//		test();
//		System.out.println("E");
//	}
//	public static void test() {
//		System.out.println("B");
//		sample();
//		System.out.println("D");
//	}
//		public static void sample() {
//			System.out.println("C");
//	
//		}
//	}
//A
//B
//C
//D
//E
//
//各文字はメソッドの呼び出し順序に従って印刷されます。
//`main` は "A" を印刷し始め、次に `test()` を呼び出します。
//`test()` は "B" を印刷し、`sample()` を呼び出して "C" を印刷し、
//`test()` に戻って "D" を印刷し、最後に `main` に戻って "E" を印刷します。
//
//
//`sample` メソッドまで来たからといって、
//プログラムが下から上に読み込まれるわけではありません。J
//avaのプログラム実行は上から下へと順序に従って進みますが、
//メソッドの呼び出しによって実行の流れが変わります。
//メソッドが呼び出されると、そのメソッド内のコードが実行され、
//メソッドの実行が完了すると、
//メソッドを呼び出した箇所の直後のコードの実行に戻ります。
//
//具体的には、`sample` メソッドが呼び出されると、
//`sample` メソッド内のコード（この場合は "C" を出力するコード）が実行されます。
//`sample` メソッドの実行が終了すると、プログラムは `sample` メソッドを呼び出した
//次の行（`test` メソッド内の "D" を出力するコード）に戻り、実行を続けます。
//
//プログラムの実行順序は以下の通りです：
//
//1. `main` メソッドが実行され、"A" が出力されます。
//2. `main` メソッドから `test` メソッドが呼び出されます。
//3. `test` メソッド内で "B" が出力されます。
//4. `test` メソッドから `sample` メソッドが呼び出されます。
//5. `sample` メソッド内で "C" が出力されます。
//6. `sample` メソッドの実行が終わり、`test` メソッドに戻ります。
//7. `test` メソッド内で "D" が出力されます。
//8. `test` メソッドの実行が終わり、`main` メソッドに戻ります。
//9. `main` メソッド内で "E" が出力されます。
//
//このように、メソッド呼び出しは実行の流れを変えますが、
//プログラムが下から上に読み込まれるわけではありません。	
//
//
//この問題のCまでの出力のされ方は理解できた！
//なぜtestメソッドに戻るのか
//なぜtestメソッドが終わったらmainメソッドに戻るのか
//全ての出力が終わったら下から上に順に出力されているわけではない？
//この辺理解できなかった
//理解できなかった点について説明しますね。
//Javaプログラムでは、メソッドの呼び出しと戻りによって実行の流れが決まります。
//プログラムが「下から上に順に出力されている」というわけではなく、
//メソッドの呼び出し順序とそれに対応する戻り（リターン）によって出力の順序が決まります。
//
//### メソッド呼び出しと戻りの流れ
//
//1. **`main`メソッドの実行開始**: プログラム実行時に最初に呼ばれるのは
//`main`メソッドです。これがプログラムの入口点です。
//
//2. **`test`メソッドの呼び出し**: `main`メソッドから`test`メソッドが呼び出されます。
//この時点で、`main`メソッドの実行は一時停止し、
//`test`メソッドのコードの実行が始まります。
//
//3. **`sample`メソッドの呼び出し**: `test`メソッドからさらに
//`sample`メソッドが呼び出されます。同様に、`test`メソッドの実行は一時停止し、
//`sample`メソッドのコードの実行が始まります。
//
//4. **`sample`メソッドの実行終了**: `sample`メソッドの実行が終わると、
//プログラムの実行は`sample`メソッドを呼び出した`test`メソッドの次の行に戻ります。
//
//5. **`test`メソッドの実行終了**: `test`メソッド内のコードの実行がすべて終わると、
//プログラムの実行は`test`メソッドを呼び出した`main`メソッドの次の行に戻ります。
//
//6. **`main`メソッドの実行終了**: `main`メソッド内のすべてのコードの実行が終わると、
//プログラム全体の実行が終了します。
//
//この流れは、「スタック」と呼ばれるデータ構造を使用して実装されています。
//メソッドが呼び出されるたびに、そのメソッドの実行情報が
//スタックに積まれ（push）、メソッドの実行が終了すると、
//その情報がスタックから取り除かれ（pop）ます。このようにして、
//どのメソッドが現在実行中で、次にどのメソッドに戻るべきかが管理されます。
//
//### 出力の順序
//
//出力が「下から上に順に」というわけではなく、
//プログラムの実行フローに従って順序が決まります。
//`main`→`test`→`sample`とメソッドが呼び出され、
//それぞれのメソッド内で出力が行われ、
//`sample`→`test`→`main`とメソッドが終了していく過程で出力順序が決定されるのです。
//
//
//D はsampleメソッドではないのか。
//Eはtestメソッドではないのか。
//
//ご質問に基づくと、少し誤解があるようですので、詳しく説明します。
//
//- "D" は `sample` メソッド内で出力されるのではなく、
//`test` メソッド内で `sample` メソッドの呼び出しの後に出力されます。
//- "E" は `test` メソッド内で出力されるのではなく、
//`main` メソッド内で `test` メソッドの呼び出しの後に出力されます。
//
//出力の流れをもう一度確認しましょう：
//
//1. **`main` メソッドが呼び出されます。**  
//    - "A" を出力します。
//    - `test` メソッドを呼び出します。
//2. **`test` メソッドが実行されます。**  
//    - "B" を出力します。
//    - `sample` メソッドを呼び出します。
//3. **`sample` メソッドが実行されます。**  
//    - "C" を出力します。
//    - `sample` メソッドが終了し、実行が `test` メソッドに戻ります。
//4. **`test` メソッドの続きが実行されます。**  
//    - "D" を出力します。
//    - `test` メソッドが終了し、実行が `main` メソッドに戻ります。
//5. **`main` メソッドの続きが実行されます。**  
//    - "E" を出力します。
//    - `main` メソッドが終了し、プログラムの実行が終わります。
//
//この流れは、メソッドの呼び出し順序とそれに対応する戻りに基づいています。
//"D" は `test` メソッドの中で、`sample` メソッドの
//実行が終了した後に出力されます。そして "E" は `main` メソッドの中で、
//`test` メソッドの実行が終了した後に出力されます。
//		
//
//Cのsampleメソッドが終了したからDに戻り、
//Eが出力されたのはtestメソッドが終了されたから出力された？
//		
//はい、その通りです。
//
//- "C" の出力が `sample` メソッド内で行われた後、
//`sample` メソッドの実行が終了します。その結果、
//プログラムの制御は `sample` メソッドを呼び出した場所、
//つまり `test` メソッドに戻ります。そして、`test` メソッド内の次の命令である
//"D" の出力が行われます。
//
//- "D" の出力が行われた後、`test` メソッド内のすべての命令の実行が完了し、
//`test` メソッドの実行が終了します。その結果、プログラムの制御は
//`test` メソッドを呼び出した場所、つまり `main` メソッドに戻ります。
//そして、`main` メソッド内の次の命令である "E" の出力が行われます。
//
//この一連の流れは、メソッドの呼び出しと戻り（リターン）によって
//コントロールされており、実行されるコードの順序を決定しています。
//プログラム実行の際には、常にメソッドが呼び出された順に
//それぞれのメソッドの実行が終了した後に、呼び出し元のメソッドに制御が戻ります。
//このようにして、プログラムのフローが管理されています。
//
//		
//		
//		5日目
//		オブジェクト指向
		
		//隙間時間（電車移動、休憩時間）にオブジェクト指向を部分読んだ。
//		
//		オブジェクト指向は考え方
//		オブジェクト指向プログラミングは開発手法
//		オブジェクト指向プログラミング言語は
//		オブジェクト指向プログラミング手法を取り入れた言語
//		
//		オブジェクト指向プログラミングでは、コピー元のことを「クラス」
//		コピーのことを「インスタンス」と呼ぶ。
//		オブジェクト指向の「オブジェクト」がオブジェクト指向プログラミングで
//		クラスとインスタンスに分かれた。
		
//		
//		Robot a = new Robot();
//		a.name = "A";
//		
//		Robot b = new Robot();
//		b.name = "B";
//		
//		a.sayHello();
//		b.sayHello();
//	}
//}
//なぜHi.I'm Aと表示されるのか？
//Hi,I'mはどこから来ているのか分からない
//	
//
//指定された出力「Hi, I'm A」と「Hi, I'm B」が表示されるということは、
//Robot クラス内の sayHello() メソッドがこの特定のメッセージを
//出力するように実装されていることを意味します。
//最初のクエリで Robot クラスのソースコードが提供されなかったため、
//記述された出力を生成する可能性のある仮想の実装を作成する必要があります。
//
//お話しになったシナリオに基づいて、
//Robot クラスが次のように実装されている可能性があります：
//		
//public class Robot {
//    String name; // ロボットの名前を格納するフィールド
//
//    public void sayHello() {
//        // ロボットが自己紹介するメッセージを出力
//        System.out.println("Hi, I'm " + name + ".");
////    }
//}
//
//この実装では、sayHello() メソッドが
//"Hi, I'm " + name + "." というメッセージをコンソールに出力します。
//ここで name は Robot オブジェクトの名前フィールドで、
//それぞれの Robot インスタンスに対して "A" または "B" と設定されます。
//
//したがって、sayHello() メソッドが呼び出されると、
//それぞれのロボットが自分の名前を使って挨拶を行います。
//この方法で "Hi, I'm A." と "Hi, I'm B." という出力が生成されるわけです。
//
//"Hi, I'm" という部分は sayHello() メソッドの中で直接記述されているため、
//この挨拶文はそのメソッドの実装から来ています。	
		
		p216のコード2つ　明日実装する。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
//		SE/プログラマーを目指すための「プログラミング（Java）学習」
//		【入門 #7】まで視聴完了
//		
		
		
		
	}
}