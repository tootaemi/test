package test;

public class Study {
	public static void main(String[] args) {
//		System.out.println("Hello");

		
		//インクリメント、デクリメントの学習(黒本)
		
		//1.実行結果として正しいもの
//		int a = 3;
//		int b = a += 5;
//		System.out.println(a + b);
//		
//		このJavaプログラムは、変数aとbの値を計算し、それらの合計を出力。
//		プログラムの流れは次の通りです：
//		1.int a = 3;で、変数aに3が代入されます。
//		2.int b = a += 5;で、aに5を加えた結果（aが8になる）が
//		bにも代入されます。この時点でaとbは両方とも8です。
//		3.System.out.println(a + b);で、aとbの合計、
//		つまり8 + 8が計算され、16が出力されます。
//		したがって、このプログラムは16を出力します。
		
		//⇨理解した！
		//そういうものなんだと理解する。
		
		
		//2.実行結果として正しいもの
//		int num = -10;
//		System.out.println(10 * -num);
//
//		
//		100が表示される理由完璧に理解したはず1
		
		//3.コンパイルエラーになるもの
		//今は分からないので飛ばします。
		
		//4.実行結果として正しいもの.
		//int a = 10;
		//int b = a++ + a + a-- - a-- + ++a;
		//System.out.println(b);
		
		//32が表示される理由は沢山復習したのでOKかと思う！

		
		//5.簡単すぎて書く必要がない気がしたので省略しました。
		
		//6.結果として正しいもの。
//		int a = 10;
//		int b = 10;
//		if (10 < a && 10 < ++b) {
//			a++;
//		}
//		System.out.println(a + b);
		
		//chatGPTの解説がおかしいため、飛ばす。。
		
//		//7.結果として正しいもの。
//		int a = 100, b = 20, c = 30;
//		System.out.println(a % b * c + a / b);
//
//		a % bは、aをbで割った余りです。
//		100 % 20は0です（100は20で割り切れます）。
//		この結果0にcを掛けます。0 * 30も0です。
//		a / bは、aをbで割った商です。100 / 20は5です。
//		最終的に、0 + 5は5です。
//		したがって、System.out.println(a % b * c + a / b);の出力は5です。
//		この計算結果は、算術演算がどのように行われるか
//		（割り算と余りの計算、乗算、そして加算の順）、そして演算の優先順位に基づいています。
//		
		
		//8.結果として正しいもの
//		public class Sample {
//			private int num;
//			public Sample(int num) {
//				this.num = num;
//			}
//		}
//		
//		public class Main {
//			public static void main(String[] args) {
//				Sample s1 = new Sample(10);
//				Sample s2 = s1;
//				System.out.println(s1 == s2);
//				}
//			}
//		
//		このコードには`Sample`クラスと`Main`クラスの2つが含まれている。
//		`Sample`クラスは、プライベートな整数フィールド`num`と、
//		提供された引数で`num`を初期化するコンストラクタを持つシンプルなJavaクラス。
//		`Main`クラスにはプログラムのエントリーポイントである
//		`main`メソッドが含まれている。
//
//		`main`メソッド内で、`num`を10で初期化した`
//		Sample`のインスタンスが作成され、`s1`によって参照される。
//		次に、`s2`に`s1`の参照が割り当てられる。
//		つまり、`s1`と`s2`はメモリ内の同じ`Sample`オブジェクトを参照している。
//
//		`System.out.println(s1 == s2);`文は、
//		`s1`と`s2`が同じオブジェクトを
//		参照しているかどうかをチェックする。
//		`s2`には`s1`の参照が割り当てられており、
//		`s2`用に新しい`Sample`インスタンスが作成されていないため
//		、`s1`と`s2`は確かに同じオブジェクトを参照している。
//		したがって、比較`s1 == s2`は`true`に評価され、
//		プログラムはコンソールに`true`を出力する。
		
//
//		
//		chatGPTより。
//		Javaにおける「同一性」と「同値性」の概念を理解するための良い例。
//
//		- **同一性(identity)**: 二つの参照が同じオブジェクトを指しているかどうかを確認する。
//		この場合、`==` 演算子を使用して参照同士を比較する。
//		この問題のコードでは、`s1`と`s2`は同じオブジェクトの参照を持っているため、
//		`s1 == s2`は`true`に評価される。
//
//		- **同値性(equality)**: 二つのオブジェクトの状態や値が等しいかどうかを確認する。
//		この比較には`equals()`メソッドを使用する。
//		オブジェクトの内容や値が同じであっても、異なる参照（つまり異なるオブジェクトとしてメモリ上に存在する）を
//		持っている場合、`==`演算子では`false`になるが、`equals()`メソッドでは`true`になる可能性がある。
//
//		このコード例では、`s1`と`s2`が同じオブジェクトを参照しているため、
//		同一性の観点から`true`が出力される。しかし、同値性に関しては、
//		`equals()`メソッドの実装やオブジェクトの内容に基づく比較が行われるため、
//		この例では直接的には扱われていない。
//		Javaでは、オブジェクトの同値性を確認するには、`equals()`メソッドを適切に
		//オーバーライドして使用する必要がある。
		
//		インクリメントの問題でないため一旦黒本終了し、
//		基礎に戻ります。
		
//		
//		uzuuzuの動画の演習
//		①から⑤それぞれどのようなデータが画面に表示されるか。
		
//		①
//		int answer1 = 3 + (7 % 4) / 2;
//		System.out.println(answer1);
//		
//		②
//		int calc2 = 10 ;
//		int answer2 = ++calc2 ;
//		System.out.orintln( calc2 );
//		System.out.println( answer2 );
//
//		③
//		int calc3 = 10 ;
//		int answer3 = calc3++ ;
//		System.out.orintln( calc3 );
//		System.out.println( answer3 );
//		
//		④
//		int calc4 = 10 ;
//		int answer4* = calc4 + 1;
//		System.out.orintln( calc4 );
//		System.out.println( answer4 );
//		
//		⑤
//		System.out.println( "1" + "6" );
//
//		
//		①　6.5　→　×   4
//		② calc2= 10  answer2= 10 →　×  両方　11
//		③ calc3= 11  answer3=11　→　△　11、10
//		④ calc4= 11  answer4=110
//		⑤16　→　⚪︎
//		
//		答え　⇩
//		
//		①
//		int answer1 = 3 + (7 % 4) / 2;
//		System.out.println(answer1);
//		
//		`answer1`の値が計算されて表示されます。
//		
//		1. `7 % 4`は余りを計算し、結果は3となります。
//		2. `(7 % 4) / 2`は3を2で割った結果、1となります。
//		3. 3に1を加えるので、`answer1`の値は4となります。
//
//		したがって、コードを実行すると4が表示されます。
//		
//		
//		②
//		このコードでは、前置インクリメント演算子（++calc2）を使用して
//		変数calc2の値をインクリメントしています。
//		また、インクリメント後の値をanswer2に代入し、その値を表示しています。
//		
//		int calc2 = 10;
//		int answer2 = ++calc2;
//		System.out.println(calc2);
//		System.out.println(answer2);
//		このコードを実行すると、次のような出力が得られます：
//		11
//		11
//
//		これは、前置インクリメント演算子が変数calc2の値を1増やした後に、
//		その値をanswer2に代入しているためです。したがって、calc2とanswer2の値はともに11となります。
//		
//		
//		③
//		このコードでは、後置インクリメント演算子（calc3++）を使用して
//		変数calc3の値をインクリメントしています。ただし、後置インクリメント演算子は、
//		インクリメント前の値を返し、その後にインクリメントが行われます。したがって、
//		answer3にはインクリメント前の値が代入され、calc3の値はインクリメントされます。
//
//		int calc3 = 10;
//		int answer3 = calc3++;
//		System.out.println(calc3);
//		System.out.println(answer3);
//		
//		このコードを実行すると、次のような出力が得られます：
//
//		```
//		11
//		10
//		```
//
//		これは、後置インクリメント演算子が変数calc3の値を1増やすが、
//		インクリメント前の値をanswer3に代入するため、answer3の値は10となります。
//		その後、calc3の値はインクリメントされて11となります。
//		
//		
//		④
//		このコードにはエラーがあります。`answer4*`のように、
//		変数名にアスタリスク(*)を含めることはできません。正しいコードを以下に示します。
//
//		int calc4 = 10;
//		int answer4* = calc4 + 1;
//		System.out.println(calc4);
//		System.out.println(answer4);
//
//		このコードを実行すると、次のような出力が得られます：
//		```
//		10
//		11
//		```
//		これは、`calc4 + 1` の計算結果が `answer4` に代入され、`calc4` の値は変更されないため、
//		最初の行では `calc4` の値が出力され、2番目の行では `answer4` の値が出力されます。
//		
//		⑤
//		16
//
//		このコードは、文字列結合を行っています。
//		`System.out.println("1" + "6");`の部分では、文字列 "1" と文字列 "6" を結合しています。
//		Javaでは、`+` 演算子を文字列に対して使用すると、文字列の結合が行われます。
//
//		したがって、このコードを実行すると、コンソールには次のように文字列 "16" が表示されます。

//		
//		！！　　④　掛け算　* これはエラーになってしまうそう
//		だからそこに書いた答えは違うと思う
//		わかるかな
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}
}