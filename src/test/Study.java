package test;

public class Study {
	public static void main(String[] args) {
//		System.out.println("Hello");

		
		//インクリメント、デクリメントの学習(黒本)
		
		//1.実行結果として正しいもの
//		int a = 3;
//		int b = a += 5;
//		System.out.println(a + b);
//		
//		このJavaプログラムは、変数aとbの値を計算し、それらの合計を出力。
//		プログラムの流れは次の通りです：
//		1.int a = 3;で、変数aに3が代入されます。
//		2.int b = a += 5;で、aに5を加えた結果（aが8になる）が
//		bにも代入されます。この時点でaとbは両方とも8です。
//		3.System.out.println(a + b);で、aとbの合計、
//		つまり8 + 8が計算され、16が出力されます。
//		したがって、このプログラムは16を出力します。
		
		//⇨理解した！
		//そういうものなんだと理解する。
		
		
		//2.実行結果として正しいもの
//		int num = -10;
//		System.out.println(10 * -num);
//
//		
//		100が表示される理由完璧に理解したはず1
		
		//3.コンパイルエラーになるもの
		//今は分からないので飛ばします。
		
		//4.実行結果として正しいもの.
		//int a = 10;
		//int b = a++ + a + a-- - a-- + ++a;
		//System.out.println(b);
		
		//32が表示される理由は沢山復習したのでOKかと思う！

		
		//5.簡単すぎて書く必要がない気がしたので省略しました。
		
		//6.結果として正しいもの。
//		int a = 10;
//		int b = 10;
//		if (10 < a && 10 < ++b) {
//			a++;
//		}
//		System.out.println(a + b);
		
		//chatGPTの解説がおかしいため、飛ばす。。
		
//		//7.結果として正しいもの。
//		int a = 100, b = 20, c = 30;
//		System.out.println(a % b * c + a / b);
//
//		a % bは、aをbで割った余りです。
//		100 % 20は0です（100は20で割り切れます）。
//		この結果0にcを掛けます。0 * 30も0です。
//		a / bは、aをbで割った商です。100 / 20は5です。
//		最終的に、0 + 5は5です。
//		したがって、System.out.println(a % b * c + a / b);の出力は5です。
//		この計算結果は、算術演算がどのように行われるか
//		（割り算と余りの計算、乗算、そして加算の順）、そして演算の優先順位に基づいています。
//		
		
		//8.結果として正しいもの
//		public class Sample {
//			private int num;
//			public Sample(int num) {
//				this.num = num;
//			}
//		}
//		
//		public class Main {
//			public static void main(String[] args) {
//				Sample s1 = new Sample(10);
//				Sample s2 = s1;
//				System.out.println(s1 == s2);
//				}
//			}
//		
//		このコードには`Sample`クラスと`Main`クラスの2つが含まれている。
//		`Sample`クラスは、プライベートな整数フィールド`num`と、
//		提供された引数で`num`を初期化するコンストラクタを持つシンプルなJavaクラス。
//		`Main`クラスにはプログラムのエントリーポイントである
//		`main`メソッドが含まれている。
//
//		`main`メソッド内で、`num`を10で初期化した`
//		Sample`のインスタンスが作成され、`s1`によって参照される。
//		次に、`s2`に`s1`の参照が割り当てられる。
//		つまり、`s1`と`s2`はメモリ内の同じ`Sample`オブジェクトを参照している。
//
//		`System.out.println(s1 == s2);`文は、
//		`s1`と`s2`が同じオブジェクトを
//		参照しているかどうかをチェックする。
//		`s2`には`s1`の参照が割り当てられており、
//		`s2`用に新しい`Sample`インスタンスが作成されていないため
//		、`s1`と`s2`は確かに同じオブジェクトを参照している。
//		したがって、比較`s1 == s2`は`true`に評価され、
//		プログラムはコンソールに`true`を出力する。
		
//
//		
//		chatGPTより。
//		Javaにおける「同一性」と「同値性」の概念を理解するための良い例。
//
//		- **同一性(identity)**: 二つの参照が同じオブジェクトを指しているかどうかを確認する。
//		この場合、`==` 演算子を使用して参照同士を比較する。
//		この問題のコードでは、`s1`と`s2`は同じオブジェクトの参照を持っているため、
//		`s1 == s2`は`true`に評価される。
//
//		- **同値性(equality)**: 二つのオブジェクトの状態や値が等しいかどうかを確認する。
//		この比較には`equals()`メソッドを使用する。
//		オブジェクトの内容や値が同じであっても、異なる参照（つまり異なるオブジェクトとしてメモリ上に存在する）を
//		持っている場合、`==`演算子では`false`になるが、`equals()`メソッドでは`true`になる可能性がある。
//
//		このコード例では、`s1`と`s2`が同じオブジェクトを参照しているため、
//		同一性の観点から`true`が出力される。しかし、同値性に関しては、
//		`equals()`メソッドの実装やオブジェクトの内容に基づく比較が行われるため、
//		この例では直接的には扱われていない。
//		Javaでは、オブジェクトの同値性を確認するには、`equals()`メソッドを適切に
		//オーバーライドして使用する必要がある。
		
//		インクリメントの問題でないため一旦黒本終了し、
//		基礎に戻ります。
		
		
		
	}
}